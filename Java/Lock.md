# 锁Lock

## 一、作用

* 在并发编程中，经常遇到多个线程访问同一个资源，为了保证数据一致性，就需要用到锁的机制。
* 参考文档：https://www.cnblogs.com/jyroy/p/11365935.html

## 二、分类

![Java锁](http://img.hurenjieee.com/Java%E9%94%81.png)

### 2.1 悲观锁 VS 乐观锁

* **悲观锁**：

  > 认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候先加锁，确保数据不会被别的线程修改。
  >
  > 在Java中，synchronized关键字和Lock的实现类都是悲观锁。

* **乐观锁**

  > 认为自己在使用数据的时候不会有别的线程修改数据，所以不会添加锁，只有在更新数据的时候去判断有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果线程已经被其他线程更新，则更具不通的实现方式执行不同的操作（失败or重试）。
  >
  > 乐观锁在Java中时通过无锁编程来实现的，最常采用CAS算法，Java原子类中的递增操作就通过CAS自旋实现的

![](http://img.hurenjieee.com/20181122101819836.png)

以上，我们可以得出：

* 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
* 乐观锁适合读操作多的场景，不加锁的特点能够使其读的性能大大提升。

### 2.2 阻塞锁 VS 非阻塞（自旋锁）

* 阻塞或唤醒一个Java线程需要操作系统切换CPU状态类完成，这种状态需要耗费处理器时间。如果同步代码中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。
* 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起合恢复现场的花费可能让系统得不偿失。如果物理机器有多个处理器，能够让同个或者以上的线程同时并行执行，我们就可以让我门那个请求的锁线程不放弃CPU的执行时间，看看持有锁的线程是否会很快就会释放锁。
* 而为了让当前线程”稍等一下“，我门需要让当前线程进行自旋，如果自旋完成后前面锁定同步的资源已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁。
* ![img](http://img.hurenjieee.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70.png)
* 自旋锁本身是有缺点的，他不能代替阻塞。自旋锁虽然避免了线程切换的开销，但它占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，若果锁占用的时间很长，那么自旋的线程只会拜拜浪费处理器资源。所以，自旋等待的额时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有陈工获得锁，就应该挂起线程。
* 自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK1.6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。
* 自适应意味着自旋的时间（次数）不在固定，而是由前一次在同一个锁上的自选时间及锁的拥有者的状态来决定。如果在同一个锁对象上，如自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理资源。

### 2.3 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

* 这四种锁是指锁的状态，专门针对synchronized的。

| 锁状态   | 存储内容                                              | 存储内容 |
| -------- | ----------------------------------------------------- | -------- |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）       | 01       |
| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁(1) | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                  | 00       |
| 重量级锁 | 指向互斥量（重量级锁）的指针                          | 10       |

* 本块内容偏向于底层，暂不学习。

### 2.4 公平锁 VS 非公平锁

* **公平锁**：

> 多个线程安装申请锁的顺序来获取锁，线程直接进入队列中排队，队列中哦功能的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率比非公平锁要低，等待队列中除第一个线程以外的所有线程都会堵塞，CPU唤醒堵塞线程的开销比非公平锁大

* **非公平锁**：

> 多个线程直接尝试获取锁，获取不到才会到等待队列的队尾等待。但是如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处理队列中的线程可能会饿死，或者等待很久才回货的锁。

### 2.5 可重入锁 VS 非可重入锁

* **可重入锁**：

> 可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象是同一个对象或者class），不回因为之前已经获取过的还是释放而阻塞。Java中的ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点就是可一定程度上避免思索。

* **非可重入锁**：

> 如果是非可重入锁，一个线程在获取锁之后不释放，再次获取锁，就会出现死锁，整个等待队列里面的所有线程都无法被唤醒。Java中的NonReentrantLock就是非可重入锁。

### 2.6 共享锁 VS 排他锁

* ReentranReadWriteLock就是共享锁和排他锁的一种体现，写触发排他锁的操作，读触发共享锁的操作。

* **共享锁**：

> 指一个锁可被多个线程持有。如果线程对数据A加上共享锁后，则其他线程只能对A在加共享锁，不能加排他锁。获取共享锁的线程只能读数据，不能修改数据。

* **排他锁**：

> 排他锁也叫独享锁，是指该锁一次只能被一个线程所持有。如果线程T对休数据A加上排他锁之后，则其他线程不能再对A加任何类型的锁。获得排他锁的线程技能读数据又能修改数据。JDK中的synchonized和JUC中的Lock的实现类就是互斥锁。

## 三、锁的实现

| 锁实现方案       | 锁结构                      | 优点                                            | 缺点                                 |
| ---------------- | --------------------------- | ----------------------------------------------- | ------------------------------------ |
| synchronized     | 悲观锁+阻塞锁               | 1. 无服务依赖<br />2. JVM层面                   | 1. 只能单机服务                      |
| Lock             | 悲观锁                      | 1. 无服务依赖<br />2. JDK层面                   | 1. 只能单机服务<br />2. 需要手动释放 |
| 数据库唯一索引锁 | 悲观锁+非阻塞锁             | 1. 实现简单                                     | 1. 锁无法自动释放                    |
| 数据库版本号锁   | 乐观锁+非阻塞锁             | 1. 实现简单                                     | 1. 锁无法自动释放，可需要判断释放    |
| Redis锁          | 悲观锁+非阻塞锁             | 1. 分布式锁<br />2. 数据锁设置延时时间          |                                      |
| Zookeeper        | 悲观锁+非阻塞锁+异步+公平锁 | 1. 分布式锁<br />2. 公平<br />3. 锁等待直接释放 |                                      |