# volatile和synchronized特点

* 首先要理解线程安全的两个方面：**执行控制**和**内存可见**；
* **执行控制**

> 执行控制的目的是控制代码的执行（顺序）及是否可以并发运行。

* **内存可见**

> 内存可见是指线程执行结果在内存中对其他线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成之后再吧结果从线程本地刷新到主存。

* synchronized关键字解决的是执行控制的问题，它会阻止其他线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其他线程访问，也就无法并发执行。更重要的是，synchronized还穿创建一个**内存屏障**，内存屏障指令保证了所有CPU操作结果都会直接刷新的主存中，从而保证了操作的内存的可见性，同时也使得先获得这个锁的线程的所有操作，都**happens-before**于随后获得这个锁的线程的操作。

* volatile关键字解决的是内存可见性的问题，会使得所有堆volatile变量的读写都会直接刷到贮存，即保证了变量的可见性。这样就能满足一些对变量可见性由要求而对读取顺序没有要求的需求。

  使用volatile关键字仅能实现对原始变量（如boolean、short、int、long等）操作的原子性，但需要特别注意，volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成（read i;inc;write i），假如多个线程同时执行i++,volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。

  在Java 5增加了原子数据类型Atomic Wrapper Classes，对他们的increase之类的操作都是原子操作，不需要使用sychronized关键字。

  对于volatile关键字，当且仅当满足以下所有条件时可使用：

>1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
>2. 该变量没有包含在具有其他变量的不变式中。

* **区别**

  | 类型       | volatile                                                     | synchronized                                               |
  | ---------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
  | 本地       | 告诉JVM当钱变量在寄存器（工作内存）中的值是不确定，需要从主存中读。 | 锁定当前变量，只有当前线程一访问该变量，其他线程被阻塞住。 |
  | 操作级别   | 变量                                                         | 变量、方法、类                                             |
  | 特性       | 修改可见性，不保证原子性                                     | 修改可见性，原子性                                         |
  | 阻塞       | 不回造成线程阻塞                                             | 可能会造成阻塞                                             |
  | 编译器优化 | 不会被编译器优化                                             | 标记的变量可以被编译器优化                                 |

  

