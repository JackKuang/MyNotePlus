# BitMap

## 一、原理

BitMap的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。

假设有这样一个需求：在20亿个随机数中找出某个数m是否在其中，并假设为32位系统，4G内存。

在Java，int 占用4个字节，1字节=8位。

如果每个数字用int存储，那就是20个int，因而占用的空间约为

(2000,000,000*4/1024/1024/1024) ==> 7.45G

如果是按位存储就不一样了，20亿个数据就是20亿为，占用空间约为

(2000,000,000/8/1024/1024/1024) ==> 0.233G

两者相差64倍。



一个byte只能存储8个数字，我们可以很容易表示[0,7]中间的数字，但是一旦超过了8，一个byte就存不下了。解决方法就是在另外一个byte上存储。

这样一看，数据结构就变成了byte数组。

> 定义byte[] temp，存储一个数字N，那么，
>
> 数据存储在temp[N/8]中的[N%8]位上。
>
> 设置值可通过 temp[N/8] = temp[N/8] | ( 1 << (N%8) ) 
>
> 清除值可通过 temp[N/8] = temp[N/8] & ( ~ (1 << (N%8) ) 



## 二、场景

### 2.1 快速排序

**原理**

> 在数据没有重复的情况下，我们可以采用BitMap来存储数据。
>
> 遍历数据时，我们只要按顺序遍历BitMap中的存贮的数据结构即可。而且速度快，时间复杂度为O(n)

**优点**

> * 运算效率高，不需要进行比较和移位
> * 占用内存小，，比如N=10000000的时候，只需占用内存为N/8=1250000Byte=1.25M

**缺点**

> * 无法重复计算。
> * 当数据比较密集时才有效。

### 2.2 快速去重

**原理**

> 20亿个证书中找出不重复的整数的个数，内存不足以容纳20亿个整数。
>
> 相比较于BitMap只能存储两个状态（有(1)或者没有(0)），这里需要扩充一下，需要3个状态：不存在(00)，出现一次(01)，有重复(11)。\
>
> 相比较我们BitMap原有的存储，快速去重需要花费原有数据两倍多内存。

### 2.3 快速查找

这就是我们一开提到的，使用byte数组来存贮数据。当然，也可以扩展为int数组。

## 三、扩展

### 3.1 BitSet

BitSet就是BitMap的算法的实现。BitSet位于java.util包下，从JDK1.0开始就已经有了。

BitSet实现了一个位向量，它可以根据需要增长。每一位都有一个布尔值。一个BitSet的位可以被负整数索引。它可以被查找、设置、清除某一位。通过逻辑运算符可以修改另一个BitSet。默认情况下，所有的位都有一个默认值false。

它底层时用一个long数组来存储，初始长度64，set值的时候先右移6位（相当于除以64）来计算存储在数组的什么位置，然后再更改状态位。

```java
 int wordIndex = wordIndex(bitIndex);
 words[wordIndex] |= (1L << bitIndex);
```

### 3.2 Bloom filter（布隆过滤器）

Bloom filter是一个数据结构，它可以用来判断某个元素是否在集合内，具有**运行快速，内存占用小**的特点。

而高效插入和查询的代价是：**Bloom Filter是一个基于概率的数据结构：它只能告诉我门一个元素绝对不再集合内或可能在集合内**。

主要应用于大数据规模下不需要精确过滤的场景，如一下

>  检查垃圾邮件地址
>
> ​		检查大量邮件中是否是垃圾邮件
>
> 爬虫URL去重
>
> ​		爬虫地址去重
>
> 解决缓存穿透问题
>
> ​		把可能的结果放入布隆过滤器，当数据访问不时避免刷新缓存或者DB挂掉 

如果想判断一个元素是不是在同一个集合里，一般想到的是将集合中所有的元素都保存起来，然后通过比较确定。连接、树、哈希表等等数据结构都是这种思维，但是随着集合中元素的增加，需要的存储空间越来越大；同样检索速度也会越来约慢，检索时间复杂度分别为O(n)、O(log n)、O(1)。

布隆过滤器的原理是，当一个元素被加入到集合时，不过K个散列函数将这个元素映射成一个位数组（Bit array）中的K个点，把他们置为1。检索时，只要看看这些点是不是都是1就知道元素是否在集合中；如果这个点有任何一个0，则被检元素一定不在；如果都是1，则被捡元素可能存在。

**BloonFilter过滤器流程**

> 1. 首先需要k个hash函数，每个函数可以把key散列称为1个整数；
> 2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0；
> 3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1；
> 4. 判断某个key是否在集合中，用k个hash函数算出k个散列值，并查询中对应的特别位，如果所有的比特位都是1，那么认为数据可能存在集合中。

![img](http://img.hurenjieee.com/uPic/874963-20191013161502813-675093298.png)

java相关实现

```xml
<dependency>
     <groupId>com.google.guava</groupId>
     <artifactId>guava</artifactId>
     <version>28.1-jre</version>
</dependency>
```

com.google.common.hash.BloomFilter



## 四、参考

https://www.cnblogs.com/cjsblog/p/11613708.html