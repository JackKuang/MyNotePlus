# BIO、NIO、AIO

## 一、概述

* Java中的BIO、NIO、AIO理解为是Java语言对操作系统的各种IO模型的封装。程序员在使用这些API的时候，不需要关心操作系统层面的只是，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API即可。
* 在理解BIO、NIO、AIO之前，先理解以下几个概念：**==同步与异步==**、**==阻塞与非阻塞==**。
* **同步与异步**：

> **同步**：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
>
> **异步**：异步就是发起一个调用后，立刻得到被调用者的回应表示已接受到请求，但被调用者并没有返回结果，此时我们可以处理其他的亲故，被调用者通常依靠事件毁掉机制来通知调用者返回结果。

​	同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者通过回调机制来通知其调用者返回结果。

* **阻塞与非阻塞**：

> **阻塞**：阻塞就是发起一个请求，调用者一致等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
>
> **非阻塞**：非阻塞就是发起一个请求，调用者不用一致等待结果返回，可以先去干其他事情。

* 举个例子（烧水）：

> **同步阻塞**：傻傻等着水开。
>
> **同步非阻塞**：时不时看下水开了没，中间去做别的事情。
>
> **异步非阻塞**：水烧开了会发出声音，听到就知道水开了，中间去做比的事情。

## 二、BIO（Blocking I/O）

* 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程那等待其完成。

### 2.1 传统BIO

* BIO通信（一请求一应答）模型图：

  ![img](http://img.hurenjieee.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA5MDQ2,size_16,color_FFFFFF,t_70.png)

* 采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接。我门一般通过while(true)循环中服务端会调用accept()方法等待接受客户端的连接的方法监听请求，请求一旦接收到一个连续请求，就可以通过建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待当前连接的客户端的操作执行完成，不过可以通过多线程来支持多个客户端的连接，如上图。

### 2.2 伪异步IO

* 伪异步IO模型图：

  ![img](http://img.hurenjieee.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA5MDQ2,size_16,color_FFFFFF,t_70-20200910221032517.png)

* 为了解决同步阻塞IO面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化——后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N。通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入到值线程耗尽。

### 2.3 总结

在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。因此，我门需要一种更高效的IO处理模型来应对更高的并发量。

## 三、NIO（New I/O）

### 3.1 NIO简介

* NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应java.nio包，提供了Channel、Selector、Buffer等抽象。
* NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的Socker和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。

> * 阻塞模式使用就像传统IO中的支持一样，比较简单，但是性能和可靠性都不好，对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性。
> * 非阻塞模式正好与之阻塞模式相反，对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。

### 3.2 NIO的特性

* **Non-blocking IO（非堵塞IO）**

> Java NIO使我们可以进行非阻塞IO操作。比如说，单线程从通道读取数据到buffer，同样可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。同样的，一个线程写数据到通道，不需要等待它完成写入，这个线程同时可以做别的事情。
>
> Java IO的各种流都是阻塞的。这意味着，当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能干任何事情了。

* **Buffer（缓冲区）**

> **IO面向流（Stream oriented），而NIO面向缓存区（Buffer orientted）**
>
> Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的重要区别。在面向流的I/O中，可以将数据直接写入或者将数据直接读到Stream对象中。虽然Stram中也有Buffer开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而NIO却是直接读到Buffer中进行操作。
>
> 在NIO库中，所有的数据都是用缓冲区处理的。在读取数据时，它是直接读取到缓冲区的；在写入数据时，也是直接写入到缓冲区的。任何时候访问NIO中的数据，都是通过缓冲区进行操作。
>
> 最常用的缓冲区就是ByteBUffer，一个ByteBuffer提供了一组功能用于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一个Java基本类型（除了Boolean类型）都对应有一种缓冲区。

* **Channel（通道）**

> NIO通过Channel（通道）进行读写。
>
> 通道是双向的，可读也可写。而流的读写是单向的。无论读写，通道只能和Buffer交互。因为Buffer，通道可以异步地读写。

* **Selector（选择器）**

> NIO有选择其，而IO没有。
>
> 选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这个通道。线程之前的切换对于操作系统来说是昂贵的。因此，为了提高系统效率，选择器是有用的。

​	![img](http://img.hurenjieee.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA5MDQ2,size_16,color_FFFFFF,t_70-20200910225453731.png)

### 3.3 NIO 读数据和写数据的方式

通常来说，NIO所有的IO都是从Channel（通道）开始的。

* 从通道进行数据读取：创建一个缓冲区，然后请求通道读取数据。
* 从通道进行数据写入：创建一个缓冲区，填充数据，并要求通道写入数据。
* ![img](http://img.hurenjieee.com/uPic/20190422121151244.png)

## 四、AIO（Asynchronous I/O）

* AIO就是NIO 2。在Java7中仅吐了改进版本的NIO 2，它是异步非阻塞IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不回堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
* AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程进行IO操作，IO操作本身就是同步的。
* 除了AIO之外，其他IO模型都是同步的。