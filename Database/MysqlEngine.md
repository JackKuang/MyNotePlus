# InnoDB和MyISAM

## 一、介绍

* MyISAM

  > MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常用的存储引擎。MyISAM拥有较高的插入、查询速度，但是不支持事物。

* InnoDB

  > InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，是InnoDB是目前MySQL的默认存储引擎。

* Memory

  > Memory存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供了快速访问。

* Archive

  > Archive之允许插入和查询，不允许修改和删除，存储大小比MyISAM小约75%，比InnoDB小约83%。当数据量非常大的时候Archive的插入性能比MyISAM要好。

## 二、对比

| 对比项目             | InnoDB                                                       | MyISAM                                                       |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事务                 | 支持                                                         | 不支持                                                       |
| 主键                 | 必须包含主键                                                 | 可不指定主键                                                 |
| 外键                 | 支持                                                         | 不支持                                                       |
| 锁                   | 表、行（默认）级锁                                           | 表锁                                                         |
| 索引                 | 聚集索引                                                     | 非聚集索引                                                   |
| 数据文件             | frm：表定义文件<br />ibd：数据文件（包含索引）               | frm：表定义文件<br />myd：数据文件<br />myi：索引文件        |
| count()函数          | 全表扫描查询                                                 | 一个变量存储了表行数                                         |
| 全文索引（FULLTEXT） | 不支持全文索引                                               | 支持全文索引                                                 |
| 存储空间             | 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 | 支持三种不同的存储结构：静态表、动态表、压缩表。当表在创建之后并倒入数据后，不回再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。 |

## 三、细节

### 3.1 为什么InnoDB的count函数不能像MyISAM一样用一个变量存储

因为InnoDB的事务特性，在同一个时刻表中的行数对于不同的事务而言是不一样呢的，因此count统计会计算当前事务而言可以统计到的行数，而不是将总行数存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的缩影。如果二级索引不存在，InnoDB还会尝试去遍历其他聚族索引。

如果索引并没有完全处理InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话，这个方案也不太好用。如果得到大致的行数值已经足够满足需求，可以尝试使show table status。

### 3.2 InnoDB为什么推荐使用自增ID作为主键

自增ID可以保证每次插入时B+索引时从右边扩展的，可以避免B+树频繁合并、分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率会比较差。

### 3.3 InnoDB引擎的4大特性

1. 插入缓存（insert buffer）
2. 二次写（double write）
3. 自适应哈希索引（ahi）
4. 预读（read ahead）

### 3.4 InnoDB于MyISAM索引的区别

* **InnoDB**

  > InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引的效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
  >
  > InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值。

  ![img](http://img.hurenjieee.com/uPic/70.png)

* **MyISAM**

  > MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，缩影保存的是数据文件的指针，主键索引和辅助索引是独立的。
  >
  > MyISAM的B+树主键索引和辅助索引的叶子节点都是在数据文件的地址指针。

  ![img](http://img.hurenjieee.com/uPic/70-20200912214253331.png)

* 聚集索引与非聚集索引

  * **聚集索引**

    > 一个汉语字典，我门希望找到“张”，可以直接翻到字典的最后，找到zh开头，然后找到张，因为字典本身就是按照拼音排版的，所以字典内容本省就是一个聚集索引。
    >
    > 聚集索引底层B+树的叶子节点是数据本身。非聚集索引底层B+树的叶子节点是指向数据的地址（有时是存的聚集索引的值，不同的实现不一样）。也就时说，聚集索引决定了数据的物理顺序，所以叶子节点本身也可以是数据。
    >
    > 由于聚集索引决定了物理顺序，所以一张表中只会有一个聚集索引。

    ![img](http://img.hurenjieee.com/uPic/Center.png)

  * **非聚集索引**

    > 在查找一个不认识的字的时候，我们可以先通过字典的偏旁部首目录，找到字在哪一页，然后通过页码找到张。因为字典不是按根据偏旁部首排版的，所以需要痛殴两步才能真正找到。
    >
    > 与聚集索引不同，一张表中可以有多个非聚集索引。

    ![img](http://img.hurenjieee.com/uPic/Center-20200912220934366.png)

### 3.4 InnoDB和MyISAM如何选择

* **InnoDB**

  > 1. 需要事务
  > 2. 并发量大，写频繁或者有复杂sql长时间执行

* MyISAM

  > 1. 并发量小
  > 2. 并发量大，复杂查询查询少，读多写少，锁竞争不激烈