# 数据权限的设计

# 一、前言

随着IT技术不断发展成熟，越来越多的行业也逐步走进了信息化行业。而在信息化建设中，数据是重要组成部分，也是极为重要的企业资产。而对于数据资产的安全建设，就显得尤为重要。权限设计贯穿于整个项目的开发周期中，无法像功能权限一样在项目要结尾的时候追加。

而数据权限的应用场景复杂，不同的行业有着各自的数据权限需求：

* 公司内部的OA系统中，员工被限制访问OA数据，行政可以查看所有员工的OA数据，部门主管可以看到本部门下的员工的OA数据，而员工只能看到自己的OA数据。
* 某销售公司，员工归属于于不同的地区，员工只能看到归属自己销售地区的数据，看不到其他销售地区的数据。
* 库存系统建设，入库员负责入库登记，出库员负责出库登记。
* 医院数据统计报表中，院长可以看到所有的统计数据，而各个科室主任只能看到自己科室的数据。
* SaaS服务（Software-as-a-Service）建设需要实现数据的租户隔离。

而单一的权限设计有时候已经很难满足需求，因此需要根据项目和需求结合技术能力实现数据。下面通过我的项目经验，总结一下权限的设计想法。

# 二、权限设计

## 2.1 多租户隔离

多租户在Saas服务中尤为常见，SaaS是一种软件部署模式，第三方供应商在云基础设施上构建应用程序，并以订阅的形式，通过互联网向客户提供这些应用程序，不要求客户预先建设底层基础设施。

SaaS服务通常基于一套标准软件系统为成百上千的不同客户(又称租户)提供服务。这要求SaaS服务要能够支持不同租户之间数据和配置的隔离，从而保证每个租户数据的安全与隐私，以及用户对诸如界面、业务逻辑、数据结构等的个性化需求。由于SaaS同时支持多个租户，每个租户可能包含多个用户，这对支撑软件的基础设施平台的性能、稳定性、扩展性具有较高要求。

### 2.1.1 分库

这种方案的实现方式是所有租户共享同一个应用，但应用后端会连接多个数据库系统，一个租户单独使用一个数据库系统。这种方案的用户数据隔离级别最高，安全性最好，租户间的数据能够实现物理隔离，但成本较高。

<img src="http://img.hurenjieee.com/uPic/image-20221025114411370.png" alt="image-20221025114411370" style="zoom:50%;" />

**实现方案：**

> 分库分表使用场景比较多，我们单独拎出来讲。

### 2.1.2 分表
这种方案的实现方式是所有租户共享同一个应用，应用后端只连接一个数据库系统，所有租户共享这个数据库系统，每个租户在数据库系统中拥有一个独立的表空间。这种方案的隔离级别较高，但是成本也较高的。

<img src="http://img.hurenjieee.com/uPic/image-20221025114433614.png" alt="image-20221025114433614" style="zoom:50%;" />

**实现方案：**

> 分库分表使用场景比较多，我们单独拎出来讲。

### 2.1.3 数据库字段隔离

这种方案的实现方式是所有租户共享同一个应用，应用后端只连接一个数据库系统，所有租户共享这个数据库系统，都添加一个用于区分租户的字段（如租户id或租户代码）来标识每条数据属于哪个租户。用户操作和查询数据都需要增加租户字段进行判断。

<img src="http://img.hurenjieee.com/uPic/image-20221025114451717.png" alt="image-20221025114451717" style="zoom:50%;" />



**实现方案：**

> Mybatis-Plus提供多租户插件可以提供到用户使用：https://baomidou.com/pages/aef2f2/#tenantlineinnerinterceptor
>
> 基于该插件可以完成数据的多租户查询。

### 2.1.4 负载均衡隔离

这种方案是在多实例系统的基础上进行负载均衡，将租户的访问请求路由到其专属的租户系统上去。这种多实例的部署架构，可以为每个租户定制代码，以及提供特色服务。

<img src="http://img.hurenjieee.com/uPic/image-20221025115156247.png" alt="image-20221025115156247" style="zoom:50%;" />

**实现方案：**

> Nginx可以根据域名或者header等方式进行分发，转发到不同的服务上，这里只是写一个基于header的demo。
>
> ```
> nginx.conf
>     server {
>         listen 80;
>         
>         underscores_in_headers on;
> 
>         location / {
>             if ($http_tenant_id = "a"){
>                 return 200 'a\n';  
>             }
>             if ($http_tenant_id = "b"){
>                 return 200 'b\n';  
>             }
>             return 200 'z\n';
>         }
> 
>     }
> 
> ```
>
> ```
> > $ curl -H "tenant_id:a" 127.0.0.1                                                                              
> a
>                                                                                                                   
> > $ curl -H "tenant_id:b" 127.0.0.1                                                                              
> b
>                                                                                                                   
> > $ curl -H "tenant_id:c" 127.0.0.1                                                                              
> z
> 
> ```
>
> 

### 2.1.5 总结

| 技术方案       | 优点                                                         | 缺点                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分库           | 1. 数据模型简单<br />2. 隔离级别最高，安全性最好，能够满足不同租户的独特需求。<br />3. 出现故障时恢复数据比较容易 | 1. 部署成本高<br />2. 数据收集分析成本高                     |
| 分表           | 1. 数据模型简单<br />2. 隔离级别较高，安全性较好<br />3. 数据恢复相对而言比较复杂 | 1.统一的数据库支持优先<br />2. 单库Schema数量大<br />3. 数据收集分析成本高 |
| 数据库字段隔离 | 1. 部署成本最低<br />2. 支持的租户数量最大<br />3. 数据收集分析成本低 | 1. 隔离级别最低<br />2. 数据恢复相对困难，容易影响到其他租户数据<br />3. 定制化需求开发复杂 |
| 负载均衡       | 1. 定制化需求开发简单，扩展简单<br />2.  隔离级别最高，安全性最好，能够满足不同租户的独特需求。<br />3. 出现故障时恢复数据比较容易 | 1. 部署成本略高<br />2. 数据收集分析成本高                   |

## 2.2 功能权限

在某业务系统中，分为前台页面和后台页面。用户只能访问到前台页面，而管理员可以访问后台页面。如果是直接授权用户，那么每加一个用户，就要给这个用户授权一遍前台页面。这就是ACL: 访问控制列表（ Access Control List）模型。

如果定义两种角色，普通用户角色可以访问前台页面，管理员角色可以访问后台页面。创建用户时绑定角色，基于角色权限去配置访问数据。这就是RBAC框架的基础模型。

RBAC 是基于角色的访问控制（Role-Based Access Control ）在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。

而在实现上，分为两个层面：

* 菜单权限：用户可以看到那些菜单

* 接口权限：后台允许用户访问哪些菜单

**实现方案：**

> * Spring Security
> * Apache shiro



## 2.3 数据权限

前面我们讲了现阶段大多数系统都会用到的两套权限方案，接下来我们谈论一下更为复杂的数据权限。

假设我们系统中的表字段信息如下：

| id | 院区  | 患者 | 挂号途径 | 挂号时间  | 挂号科室 | 就诊医生 | 诊断内容 | 付款方式 | 付款金额 |
| ---- | ---- | -------- | ---- | ---- | -------- | -------- | ---- | -------- | ---- |
| 1 | 东院区 | 张三 | 微信 | 20220101 | 内科 | 张三三 | a | 支付宝 | 1 |
| 2 | 东院区 | 李四 | 微信 | 20220101 | 内科 | 李四四 | a | 支付宝 | 2 |
| 3 | 西院区 | 王五 | 微信 | 20220101 | 骨科 | 王五五 | a | 支付宝 | 3 |
| 4 | 西院区 | 赵六 | 支付宝 | 20220101 | 外科 | 赵六六 | a | 支付宝 | 4 |

| 就诊医生 | 科室 | 用户 |
| -------- | ---- | ---- |
| 张三三   | 内科 | 医生 |
| 李四四   | 内科 | 医生 |
| 王五五   | 骨科 | 医生 |
| 赵六六   | 外科 | 医生 |
| 李七七   | 院长 | 院长 |
| 丁八八   | 财务 | 财务 |

场景一（基于科室授权行权限）：

* 内科医生只能看到内科的统计数据
* 院长可以看到所有的科室统计数据

场景二（基于角色授权列权限）：

* 医院财务无法看到诊断内容



综上，我们可以定义出需求如下：

* 资源可能是行数据或是列数据
* 资源授权可基于科室、角色、用户等层面



### 2.3.1 行权限

行权限即数据过滤，即当用户进行数据查询时，数据需要进行一定的过滤才可以展示。

在功能实现上，在每个角色下定义行权限，再根据用户属性再获取到行权限。这样的设计可以快速、简单的满足需求。

设计UI如下：

![image-20221026112903085](http://img.hurenjieee.com/uPic/image-20221026112903085.png)

**技术方案：**

> 在该场景下，动态生成查询sql时增加where条件。如果一个用户设计多个行权限，这些行权限之间使用or进行处理。



### 2.3.2 列权限

列权限即数据查询字段，即当用户进行数据查询，仅展示能展示的字段。

在功能实现上，和行权限一致，在每个角色下定列行权限，再根据用户属性再获取到列权限。这样的设计可以快速、简单的满足需求。设计UI如下：

![image-20221026135213984](http://img.hurenjieee.com/uPic/image-20221026135213984.png)

**技术方案：**

> 在该场景下，动态生成查询sql时生成select 字段。如果一个用户设计多个列权限，这些字段进行并集处理。



###  2.3.3 动态绑定授权

在固定页面系统中，配置行列权限似乎没啥问题。因为授权的字段既是是数据源字段。

但是如果是报表系统则是很大的不同，因此报表来源于各种数据源查询出来的SQL，字段不固定，则需要每个报表单独都需要配置一下行权限、列权限。一旦用户体系大一点，授权工作就会无限叠加。

此时，就需要把配置固定化，让报表来适配统一的权限配置。

![image-20221026142416651](http://img.hurenjieee.com/uPic/image-20221026142416651.png)



**实现流程：**

> 1. 定义权限字段，比方说：科室，角色
> 2. 绑定到用户上，比方说：授权内科，只能查询到【科室=内科】数据。
> 3. 报表绑定权限字段，比如：报表中的挂号科室绑定到权限的科室字段。
>
> 依赖于以上的绑定关系，就可以动态的绑定字段到用户权限上。



# 三、总结

以上都是我经历过的权限系统设计中的集中方案，但是权限本身会和系统强相关。业务系统会使用更多的使用功能权限，数据系统则会使用数据权限更多。

权限的功能设计也要考虑到用户使用的成本，复杂的权限逻辑不但增加整体开发的工作量，还会增加用户的理解和使用成本，最终变成一个复杂的产品。
